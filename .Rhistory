boxplot_func(outcome, cleaned_df,1,2)
boxplot_func(health_outcomes, cleaned_df,3,2)
boxplot_func(social_economic_factors, cleaned_df,3,1)
boxplot_func(health_behavior, cleaned_df,2,1)
boxplot_func(physical_environment, cleaned_df,3,2)
boxplot_func(clinical_care, cleaned_df,2,1)
#histogram for all metrics
hist_func <- function(metric_group, df, num_rows, num_cols){
par(mfrow= c(num_rows,num_cols), mar = c(3,3,3,3))
for (i in metric_group) {
hist(as.numeric(unlist(df[i])), main=i, xlab = i)
}
}
hist_func(outcome, cleaned_df, 1,2)
hist_func(health_outcomes, cleaned_df, 3,2)
hist_func(social_economic_factors, cleaned_df, 3,1)
hist_func(health_behavior, cleaned_df, 2,1)
hist_func(physical_environment, cleaned_df, 3,2)
hist_func(clinical_care, cleaned_df, 2,1)
#scatterplots comparing breast cancer deaths to the covariates
scatterplot_func <- function(metric_group, df, num_row, num_cols,
cancer_type, main_title, xlab_title){
par(mfrow= c(num_row,num_cols), mar = c(2.5,2.5,2.5,2.5))
for (i in metric_group) {
plot(as.numeric(unlist(df[cancer_type])), as.numeric(unlist(df[i])),
main=paste(main_title,i), xlab = xlab_title, ylab=i)
}
}
scatterplot_func(health_outcomes, cleaned_df, 3,2,"Breast_cancer_deaths",
"Breast Cancer Deaths \n vs ", "Breast Cancer Deaths")
scatterplot_func(social_economic_factors, cleaned_df, 3,1,"Breast_cancer_deaths",
"Breast Cancer Deaths \n vs ", "Breast Cancer Deaths")
scatterplot_func(health_behavior, cleaned_df, 2,1,"Breast_cancer_deaths",
"Breast Cancer Deaths \n vs ", "Breast Cancer Deaths")
scatterplot_func(physical_environment, cleaned_df, 3,2,"Breast_cancer_deaths",
"Breast Cancer Deaths \n vs ", "Breast Cancer Deaths")
scatterplot_func(clinical_care, cleaned_df, 2,1,"Breast_cancer_deaths",
"Breast Cancer Deaths \n vs ", "Breast Cancer Deaths")
#scatterplots comparing Colorectal cancer deaths to the covariates
scatterplot_func(health_outcomes, cleaned_df, 3,2,"Colorectal_cancer_deaths",
"Colorectal Cancer Deaths \n vs ", "Colorectal Cancer Deaths")
scatterplot_func(social_economic_factors, cleaned_df, 3,1,"Colorectal_cancer_deaths",
"Colorectal Cancer Deaths \n vs ", "Colorectal Cancer Deaths")
scatterplot_func(health_behavior, cleaned_df, 2,1,"Colorectal_cancer_deaths",
"Colorectal Cancer Deaths \n vs ", "Colorectal Cancer Deaths")
scatterplot_func(physical_environment, cleaned_df, 3,2,"Colorectal_cancer_deaths",
"Colorectal Cancer Deaths \n vs ", "Colorectal Cancer Deaths")
scatterplot_func(clinical_care, cleaned_df, 2,1,"Colorectal_cancer_deaths",
"Colorectal Cancer Deaths \n vs ", "Colorectal Cancer Deaths")
knitr::opts_chunk$set(echo = TRUE,tidy.opts=list(width.cutoff=50),tidy=TRUE)
rm(list = ls())
gc(reset = TRUE)
library(rstudioapi)
library(tidyverse)
getActiveDocumentContext()$path
working_path <- dirname(getActiveDocumentContext()$path)
setwd(working_path)
#Data from https://www.cityhealthdashboard.com/metrics
#read in data
data<-read_csv("CHDB_data_city_all v9_0.csv")
#total_pop <- data[which(data$group_name=="total population"),]
#View(total_pop[duplicated(total_pop[c("city_name","metric_name","data_yr_type")]),])
library(rvest)
library(lubridate)
library(ggplot2)
library(readxl)
library(stringr)
#covariates available in total population, and by gender
unique(data$metric_name)
unique(data[data$group_name=="female",]$metric_name)
unique(data[data$group_name=="male",]$metric_name)
variable_list <- c("Diabetes","High blood pressure","Frequent Mental distress",
"Frequent physical distress","Obesity","Life expectancy",
"Premature deaths","Racial/ethnic diversity", "Income Inequality",
"Unemployment","Binge drinking","Physical inactivity","Smoking",
"Air pollution - particulate matter","Housing with potential lead risk",
"Lead exposure risk index","Limited access to healthy foods",
"Breast cancer deaths","Colorectal cancer deaths","Preventive services", "Uninsured")
#subset to only city name, metric name, year, and estimate (value),
#look at total_population metrics, and subset to only metrics of interest
subset_data <- data[which((data$group_name=="total population") &
(data$metric_name %in% variable_list)),][c("city_name","state_abbr","metric_name","data_yr_type","est")]
#Read in top 200 cities and clean up to match to subset_data
# taken from https://worldpopulationreview.com/us-cities
top_200_cities <- read_csv("top_200_cities.csv")
top_100_cities <- top_200_cities %>% slice(1:103) #NOTE: San Juan and Paradise aren't in the Langone Dataset, so include the next 2 largest cities
names(top_100_cities)[which(names(top_100_cities) %in% c("name","usps"))] <- c("city_name","state_abbr")
#change names for "Boise" and "New York City" to "Boise City" and "New York"
top_100_cities$city_name[which(top_100_cities$city_name %in% c("Boise", "New York City"))] <- c("New York","Boise City")
#filter for just top 100 cities in subset_data
city_state <- paste0(top_100_cities$city_name,", ",top_100_cities$state_abbr)
data_city_state <- paste0(subset_data$city_name,", ",subset_data$state_abbr)
subset_top_100_cities <- subset_data[which(data_city_state %in% city_state),]
length(unique(paste0(subset_top_100_cities$city_name,", ",subset_top_100_cities$state_abbr)))
#Shows San Juan and Paradise aren't in the dataset
top_100_cities$city_name[which(!(top_100_cities$city_name %in% unique(subset_top_100_cities$city_name)))]
#data checks
cities_transformed <- subset_top_100_cities %>% spread(metric_name, est)
subset_top_100_cities$metric_year <- paste0(subset_top_100_cities$metric_name,
"_",subset_top_100_cities$data_yr_type)
cities_years_check <- subset_top_100_cities[c("city_name","state_abbr","metric_year","est")] %>%
spread(metric_year, est)
#check how many values there are for each metric;
#if there aren't multiple values across years for a given metric and city
metric_value_count_by_city <- subset_top_100_cities %>%
group_by(city_name, state_abbr, metric_name) %>%
summarize(n= n())
sum(metric_value_count_by_city$n != 1)
#since there's only 1 value for each metric for each city, remove data_yr_type
final_data_long <- subset_top_100_cities[c("city_name","state_abbr","metric_name","est")]
#convert from long to wide format; have each metric name as a column
cleaned_df <- final_data_long %>% spread(metric_name, est)
#check for missing data
cleaned_df[which(is.na(cleaned_df$`Air pollution - particulate matter`)),]
#Data represent modeled estimates produced by Community Multiscale Air Quality (CMAQ) model and do not include estimates for Alaska and Hawaii.
#add values for air pollution for honolulu and anchorage from other sources
honolulu_2016_air_pollution <- 13.8 #https://health.hawaii.gov/cab/files/2019/07/aqbook_2016.pdf pg 18
anchorage_2016_air_pollution <- 6.5 #https://www.muni.org/Departments/OCPD/Planning/AMATS/MTP/2040/Chpaters/2040_MTP_Chapter_9_Air_Quality.pdf
cleaned_df$`Air pollution - particulate matter`[which(cleaned_df$city_name=="Anchorage")] <- anchorage_2016_air_pollution
cleaned_df$`Air pollution - particulate matter`[which(cleaned_df$city_name=="Honolulu")] <- honolulu_2016_air_pollution
#replace spaces with _ in column names
names(cleaned_df)<-str_replace_all(names(cleaned_df), c(" " = "_" , "," = "" ))
names(cleaned_df)<-str_replace_all(names(cleaned_df), c("-" = "_" , "," = "" ))
names(cleaned_df)<-str_replace_all(names(cleaned_df), c("/" = "_" , "," = "" ))
#multiply Colorectal_cancer_deaths and Breat_cancer_deaths by 10 to make it discrete
cleaned_df$Colorectal_cancer_deaths <- cleaned_df$Colorectal_cancer_deaths*10
cleaned_df$Breast_cancer_deaths <- cleaned_df$Colorectal_cancer_deaths*10
dim(cleaned_df)
summary(cleaned_df)
#break down metrics into groups
outcome <- c("Breast_cancer_deaths","Colorectal_cancer_deaths")
health_outcomes <- c("Diabetes","High_blood_pressure","Frequent_physical_distress",
"Life_expectancy", "Obesity")
social_economic_factors <- c("Income_Inequality","Racial_ethnic_diversity","Unemployment")
health_behavior <- c("Binge_drinking","Physical_inactivity")
physical_environment <- c("Air_pollution___particulate_matter","Housing_with_potential_lead_risk",
"Limited_access_to_healthy_foods")
clinical_care <- c("Preventive_services","Uninsured")
library(corrplot)
health_outcomes_df <- cleaned_df[c(outcome, health_outcomes)]
social_economic_factors_df <- cleaned_df[c(outcome, social_economic_factors)]
health_behavior_df <- cleaned_df[c(outcome, health_behavior)]
physical_environment_df <- cleaned_df[c(outcome, physical_environment)]
clinical_care_df <- cleaned_df[c(outcome, clinical_care)]
#correlation matrices by
corrplot(cor(health_outcomes_df),method="number", number.cex= 5/ncol(health_outcomes_df))
corrplot(cor(social_economic_factors_df),method="number", number.cex= 5/ncol(health_outcomes_df))
corrplot(cor(health_behavior_df),method="number", number.cex= 5/ncol(health_outcomes_df))
corrplot(cor(physical_environment_df),method="number", number.cex= 5/ncol(health_outcomes_df))
corrplot(cor(clinical_care_df),method="number", number.cex= 5/ncol(health_outcomes_df))
#boxplots for all metrics
boxplot_func <- function(metric_group, df, num_rows, num_cols){
par(mfrow= c(num_rows,num_cols), mar = c(3,3,1.5,1.5))
for (i in metric_group) {
boxplot(df[i], main=i)
}
}
boxplot_func(outcome, cleaned_df,1,2)
boxplot_func(health_outcomes, cleaned_df,3,2)
boxplot_func(social_economic_factors, cleaned_df,3,1)
boxplot_func(health_behavior, cleaned_df,2,1)
boxplot_func(physical_environment, cleaned_df,3,2)
boxplot_func(clinical_care, cleaned_df,2,1)
#scatterplots comparing breast cancer deaths to the covariates
scatterplot_func <- function(metric_group, df, num_row, num_cols,
cancer_type, main_title, xlab_title){
par(mfrow= c(num_row,num_cols), mar = c(2.5,2.5,2.5,2.5))
for (i in metric_group) {
plot(as.numeric(unlist(df[cancer_type])), as.numeric(unlist(df[i])),
main=paste(main_title,i), xlab = xlab_title, ylab=i)
}
}
scatterplot_func(health_outcomes, cleaned_df, 3,2,"Breast_cancer_deaths",
"Breast Cancer Deaths \n vs ", "Breast Cancer Deaths")
scatterplot_func(social_economic_factors, cleaned_df, 3,1,"Breast_cancer_deaths",
"Breast Cancer Deaths \n vs ", "Breast Cancer Deaths")
scatterplot_func(health_behavior, cleaned_df, 2,1,"Breast_cancer_deaths",
"Breast Cancer Deaths \n vs ", "Breast Cancer Deaths")
scatterplot_func(physical_environment, cleaned_df, 3,2,"Breast_cancer_deaths",
"Breast Cancer Deaths \n vs ", "Breast Cancer Deaths")
scatterplot_func(clinical_care, cleaned_df, 2,1,"Breast_cancer_deaths",
"Breast Cancer Deaths \n vs ", "Breast Cancer Deaths")
#scatterplots comparing Colorectal cancer deaths to the covariates
scatterplot_func(health_outcomes, cleaned_df, 3,2,"Colorectal_cancer_deaths",
"Colorectal Cancer Deaths \n vs ", "Colorectal Cancer Deaths")
scatterplot_func(social_economic_factors, cleaned_df, 3,1,"Colorectal_cancer_deaths",
"Colorectal Cancer Deaths \n vs ", "Colorectal Cancer Deaths")
scatterplot_func(health_behavior, cleaned_df, 2,1,"Colorectal_cancer_deaths",
"Colorectal Cancer Deaths \n vs ", "Colorectal Cancer Deaths")
scatterplot_func(physical_environment, cleaned_df, 3,2,"Colorectal_cancer_deaths",
"Colorectal Cancer Deaths \n vs ", "Colorectal Cancer Deaths")
scatterplot_func(clinical_care, cleaned_df, 2,1,"Colorectal_cancer_deaths",
"Colorectal Cancer Deaths \n vs ", "Colorectal Cancer Deaths")
#Poisson Analysis CRC deaths; get the p-values for each model with single covariate; mulitply by 10 to get whole number.
#colorectal cancer deaths will be per 1 million, no other values
offset_value <- rep(1000000, dim(cleaned_df)[1])
summary(glm(Colorectal_cancer_deaths ~ Air_pollution___particulate_matter,
family="poisson", offset = offset_value,  data=cleaned_df))$coeff
summary(glm(Colorectal_cancer_deaths ~ Binge_drinking,
family="poisson", offset = offset_value,  data=cleaned_df))$coeff
summary(glm(Colorectal_cancer_deaths ~ Diabetes,
family="poisson", offset = offset_value,  data=cleaned_df))$coeff
summary(glm(Colorectal_cancer_deaths ~ Frequent_physical_distress,
family="poisson", offset = offset_value,  data=cleaned_df))$coeff
summary(glm(Colorectal_cancer_deaths ~ High_blood_pressure,
family="poisson", offset = offset_value,  data=cleaned_df))$coeff
summary(glm(Colorectal_cancer_deaths ~ Income_Inequality,
family="poisson", offset = offset_value,  data=cleaned_df))$coeff
summary(glm(Colorectal_cancer_deaths ~ Lead_exposure_risk_index,
family="poisson", offset = offset_value,  data=cleaned_df))$coeff
summary(glm(Colorectal_cancer_deaths ~ Limited_access_to_healthy_foods,
family="poisson", offset = offset_value,  data=cleaned_df))$coeff
summary(glm(Colorectal_cancer_deaths ~ Obesity,
family="poisson", offset = offset_value,  data=cleaned_df))$coeff
summary(glm(Colorectal_cancer_deaths ~ Physical_inactivity,
family="poisson", offset = offset_value,  data=cleaned_df))$coeff
summary(glm(Colorectal_cancer_deaths ~ Preventive_services,
family="poisson", offset = offset_value,  data=cleaned_df))$coeff
summary(glm(Colorectal_cancer_deaths ~ Racial_ethnic_diversity,
family="poisson", offset = offset_value,  data=cleaned_df))$coeff
summary(glm(Colorectal_cancer_deaths ~ Smoking,
family="poisson", offset = offset_value,  data=cleaned_df))$coeff
summary(glm(Colorectal_cancer_deaths ~ Uninsured,
family="poisson", offset = offset_value,  data=cleaned_df))$coeff
colorectal_poisson_model_function<- function(df){
poisson_model <- glm(Colorectal_cancer_deaths ~.,family="poisson", offset = offset_value,
data=df[,which(names(df)!="Breast_cancer_deaths")])
return(poisson_model)
}
#Health Outcomes as the predictor
health_outcomes_model <- colorectal_poisson_model_function(health_outcomes_df)
summary(health_outcomes_model)
#Poisson Model with SES as predictors
social_economic_factors_model<-colorectal_poisson_model_function(social_economic_factors_df)
summary(social_economic_factors_model)
#Poisson Model with health behavior as predictors
health_behavior_model <- colorectal_poisson_model_function(health_behavior_df)
summary(health_behavior_model)
summary(physical_environment_model)
#Poisson Model with physical environment as predictors
physical_environment_model <- colorectal_poisson_model_function(physical_environment_df)
summary(physical_environment_model)
#Poisson Model with clinical care as predictors
clinical_care_model<- colorectal_poisson_model_function(clinical_care_df)
summary(clinical_care_model)
#All covariates
full_model <- glm(Colorectal_cancer_deaths ~ Binge_drinking+Diabetes+Frequent_physical_distress+
High_blood_pressure+Income_Inequality+Obesity+Physical_inactivity+
Preventive_services+Smoking+Uninsured,family="poisson", offset = offset_value,  data=cleaned_df)
summary(full_model)
# Poisson elastic net--------------------------------------------------
x <- cleaned_df %>% select(-c(Colorectal_cancer_deaths,city_name, state_abbr,
Breast_cancer_deaths)) %>% data.matrix()
y <- cleaned_df %>% select(Colorectal_cancer_deaths) %>% data.matrix()
poisson_elasticnet_col_cancer_model <- cv.glmnet(x, y, family= "poisson")
#lambda.min is the value of lambea that gives minimum mean cross-validated error
poisson_elasticnet_col_cancer_model$lambda.min
#covariates with a slope estimate are included in best model
poisson_elasticnet_coeff <- coef(poisson_elasticnet_col_cancer_model, s = "lambda.min")
poisson_elasticnet_coeff
#covariates to include in poisson model to have minimum mean corss-validated error:
rownames(poisson_elasticnet_coeff)[which(poisson_elasticnet_coeff != 0)]
#fit new model
poisson_model_enet <- glm(Colorectal_cancer_deaths ~ Air_pollution___particulate_matter+
Binge_drinking+Frequent_physical_distress+
Housing_with_potential_lead_risk+Income_Inequality+
Life_expectancy+Limited_access_to_healthy_foods+
Obesity+Preventive_services+Racial_ethnic_diversity+Unemployment, family="poisson",
offset = offset_value,
data=cleaned_df, )
summary(poisson_model_enet)
deviance(health_outcomes_model)/health_outcomes_model$df.residual
deviance(social_economic_factors_model)/social_economic_factors_model$df.residual
deviance(health_behavior_model)/health_behavior_model$df.residual
deviance(physical_environment_model)/physical_environment_model$df.residual
deviance(clinical_care_model)/clinical_care_model$df.residual
deviance(full_model)/full_model$df.residual
# Checking for overdispersion (elastic net poisson model)
deviance(poisson_model_enet)/poisson_model_enet$df.residual
head(data)
unique(data$group_name)
f <- data %>% filter(group_name=="female")
unique(f$metric_name)
rm(list = ls())
gc(reset = TRUE)
getActiveDocumentContext()$path
working_path <- dirname(getActiveDocumentContext()$path)
setwd(working_path)
library(tidyverse)
library(ggplot2)
library(zoo)
library(mice)
library(lme4)
mcar_data <- read_csv("clean_data/mcar_data.csv")
mar_data <- read_csv("clean_data/mar_data.csv")
# creating missing indicator column
mar_data$missing_ind <- is.na(mar_data$suicides_no)*1
mcar_data$missing_ind <- is.na(mcar_data$suicides_no)*1
# remove 2016 since it has missing age values
mar_data <- mar_data %>% filter(year != 2016)
mcar_data <- mcar_data %>% filter(year != 2016)
# https://stackoverflow.com/questions/2776135/last-observation-carried-forward-in-a-data-frame
lvcf_mcar_data <- na.locf(mcar_data)
lvcf_mar_data <- na.locf(mar_data)
ps_match <- function(data) {
# run logistic regression of covariates on missing indicator & get predicted probs
logit <- glm(missing_ind ~ year + factor(country) + population + gdp_for_year + female + mean_age, family="binomial", data=data)
ps <- predict(logit, type="response")
data$ps <- ps
# create seperate dfs for missing and not missing data
data_missing <- data %>% filter(is.na(suicides_no))
data_not_missing <- data %>% filter(!is.na(suicides_no))
suicides_no_imp <- rep(NA, length(data_missing$ps))
for (i in 1:length(data_missing$ps)) {
ps_missing <- data_missing$ps[i]
# filter compare missing obs propensity to other propensities for observed obs within same country
missing_country <- data_missing %>%
filter(ps == ps_missing) %>%
select(country) %>% pull(.)
# take abs difference between missing obs propensity and each observed obs within country
df <- data_not_missing %>%
filter(country == missing_country) %>%
mutate(abs_diff = abs(ps_missing - ps))
# find min of abs differences
imp <- df %>%
filter(abs_diff == min(df$abs_diff)) %>%
select(suicides_no) %>%
pull(.)
suicides_no_imp[i] <- imp
}
data_missing$suicides_no_imp <- suicides_no_imp
# join imputed suicide number values to full data frame
ps_data <- data %>%
left_join(data_missing %>%
select(country_year, suicides_no_imp), by = "country_year")
# create vectors of imputed suicide values and original suicide values
ps_suicides_no_org <- ps_data %>%
filter(missing_ind == 1) %>%
select(suicides_no_org) %>% pull(.)
ps_suicides_no_imp <- ps_data %>%
filter(missing_ind == 1) %>%
select(suicides_no_imp) %>% pull(.)
mse_ps <- mean((ps_suicides_no_imp - ps_suicides_no_org)^2)
result <- list(ps_data = ps_data,
mse_ps = mse_ps)
return(result)
}
mcar_ps <- ps_match(mcar_data)
ps_mcar_data <- mcar_ps$ps_data
mar_ps <- ps_match(mar_data)
ps_mar_data <- mar_ps$ps_data
names(mcar_data)
imp_mcar <- mice(mcar_data %>% select(suicides_no,population,gdp_per_capita,female,year,country), method = "norm.predict", m = 1)
imp_mcar <- mice(mcar_data %>% select(suicides_no,gdp_for_year,gdp_per_capita,female,year,country), method = "norm.predict", m = 1)
imp_mcar <- mice(mcar_data %>% select(suicides_no,suicies_no_org,gdp_per_capita,female,year,country), method = "norm.predict", m = 1)
imp_mcar <- mice(mcar_data %>% select(suicides_no,suicides_no_org,gdp_per_capita,female,year,country), method = "norm.predict", m = 1)
imp_mcar <- mice(mcar_data %>% select(suicides_no,suicides_no_org,population_change,gdp_per_capita,female,year,country), method = "norm.predict", m = 1)
imp_mcar <- mice(mcar_data %>% select(suicides_no,suicides_no_org,population_change,mean_age,gdp_per_capita,female,year,country), method = "norm.predict", m = 1)
# Store data
data_imp_mcar <- complete(imp_mcar)
length(which(is.na(data_imp_mcar$suicides_no)))
imp_mcar <- mice(mcar_data %>% select(suicides_no,suicides_no_org,mean_age,gdp_per_capita,female,year,country), method = "norm.predict", m = 1)
# Store data
data_imp_mcar <- complete(imp_mcar)
length(which(is.na(data_imp_mcar$suicides_no)))
imp_mcar <- mice(mcar_data %>% select(suicides_no,suicides_no_org,mean_age,gdp_per_capita,female,year,country), method = "norm.predict", m = 1)
length(which(is.na(data_imp_mcar$suicides_no)))
imp_mcar <- mice(mcar_data %>% select(suicides_no,mean_age,gdp_per_capita,female,year,country), method = "norm.predict", m = 1)
length(which(is.na(data_imp_mcar$suicides_no)))
imp_mcar <- mice(mcar_data %>% select(suicides_no,mean_age,gdp_per_capita,female,year,country), method = "norm.predict", m = 1)
# Store data
data_imp_mcar <- complete(imp_mcar)
length(which(is.na(data_imp_mcar$suicides_no)))
imp_mcar <- mice(mcar_data %>% select(suicides_no,mean_age,gdp_per_capita,female,year,country), method = "norm.predict", m = 1)
imp_mar <- mice(mar_data %>% select(suicides_no,mean_age,gdp_per_capita,female,year,country), method = "norm.predict", m = 1)
# Store data
data_imp_mcar <- complete(imp_mcar)
data_imp_mar <- complete(imp_mar)
length(which(is.na(data_imp_mcar$suicides_no)))
length(which(is.na(data_imp_mar$suicides_no)))
View(data_imp_mcar)
View(mcar_data)
imp_mcar <- mice(mcar_data %>% select(suicides_no,mean_age,gdp_per_capita,female,year,country),group=country, method = "norm.predict", m = 1)
imp_mcar <- mice(mcar_data %>% select(suicides_no,mean_age,gdp_per_capita,female,year,country),group="country", method = "norm.predict", m = 1)
# Store data
data_imp_mcar <- complete(imp_mcar)
#check that there's no missing data in imputed dataset
length(which(is.na(data_imp_mcar$suicides_no)))
imp_mcar <- mice(mcar_data %>% select(suicides_no,mean_age,gdp_per_capita,female,year,country),group="country", method = "norm.predict", m = 1)
imp_mar <- mice(mar_data %>% select(suicides_no,mean_age,gdp_per_capita,female,year,country), group="country",method = "norm.predict", m = 1)
# Store data
data_imp_mcar <- complete(imp_mcar)
data_imp_mar <- complete(imp_mar)
View(data_imp_mar)
impute_mcar_df <- mcar_data %>% select(suicides_no,mean_age,gdp_per_capita,female,year,country)
#impute by country
df.clean<-lapply(split(impute_mcar_df,impute_mcar_df$country), function(x) mice::complete(mice(x,m=1)))
impute_mcar_df <- mcar_data %>% select(suicides_no,mean_age,gdp_per_capita,female,country)
#impute by country
df.clean<-lapply(split(impute_mcar_df,impute_mcar_df$country), function(x) mice::complete(mice(x,m=1)))
warnings()
impute_mcar_df <- mcar_data %>% select(suicides_no,mean_age,female,year,country)
#impute by country
df.clean<-lapply(split(impute_mcar_df,impute_mcar_df$country), function(x) mice::complete(mice(x,m=1)))
#impute by country
df.clean<-lapply(split(impute_mcar_df,impute_mcar_df$country), function(x) mice::complete(mice(x,m=1,method = "norm.predict",)))
impute_mcar_df <- mcar_data %>% select(suicides_no,mean_age,gdp_per_capita,female,year,country)
#impute by country
df.clean<-lapply(split(impute_mcar_df,impute_mcar_df$country), function(x) mice::complete(mice(x,m=1,method = "norm.predict",)))
debug(df.clean)
debug(lapply(split(impute_mcar_df,impute_mcar_df$country), function(x) mice::complete(mice(x,m=1,method = "norm.predict",))))
#impute by country
df.clean<-lapply(split(impute_mcar_df,impute_mcar_df$country), function(x) mice::complete(mice(x[,which(names(x) != "country")],m=1,method = "norm.predict",)))
#impute by country
df.clean<-lapply(split(impute_mcar_df,impute_mcar_df$country), function(x) mice::complete(mice(x[,which(names(x) != "country")],m=1,method = "norm.predict",)))
#impute by country
df.clean<-lapply(split(impute_mcar_df,impute_mcar_df$country), function(x) mice::complete(mice(x[,which(names(x) != "country")],m=1,method = "norm.predict",)))
imp_mcar <- mice(mcar_data %>% select(suicides_no,mean_age,gdp_per_capita,female,year,country),group="country", method = "norm.predict", m = 1)
imp_mar <- mice(mar_data %>% select(suicides_no,mean_age,gdp_per_capita,female,year,country), group="country",method = "norm.predict", m = 1)
# Store data
data_imp_mcar <- complete(imp_mcar)
data_imp_mar <- complete(imp_mar)
impute_mcar_df <- mcar_data %>% select(suicides_no,mean_age,gdp_per_capita,female,year,country)
impute_mar_df <- mar_data %>% select(suicides_no,mean_age,gdp_per_capita,female,year,country)
#impute by country
df.clean<-lapply(split(impute_mcar_df,impute_mcar_df$country), function(x) mice::complete(mice(x[,which(names(x) != "country")],m=1,method = "norm.predict",)))
#impute by country
df.clean<-lapply(split(impute_mcar_df,impute_mcar_df$country), function(x) mice::complete(mice(x[,which(names(x) != "country")],m=1,method = "norm.predict",)))
undebug(df.clean)
undebug()
undebug(impute_mcar_df)
undebug(lapply(split(impute_mcar_df,impute_mcar_df$country), function(x) mice::complete(mice(x[,which(names(x) != "country")],m=1,method = "norm.predict",))))
#impute by country
df.clean<-lapply(split(impute_mcar_df,impute_mcar_df$country), function(x) mice::complete(mice(x[,which(names(x) != "country")],m=1,method = "norm.predict",)))
rm(list = ls())
gc(reset = TRUE)
getActiveDocumentContext()$path
working_path <- dirname(getActiveDocumentContext()$path)
setwd(working_path)
library(tidyverse)
library(ggplot2)
library(zoo)
library(mice)
library(lme4)
mcar_data <- read_csv("clean_data/mcar_data.csv")
mar_data <- read_csv("clean_data/mar_data.csv")
# creating missing indicator column
mar_data$missing_ind <- is.na(mar_data$suicides_no)*1
mcar_data$missing_ind <- is.na(mcar_data$suicides_no)*1
# remove 2016 since it has missing age values
mar_data <- mar_data %>% filter(year != 2016)
mcar_data <- mcar_data %>% filter(year != 2016)
# https://stackoverflow.com/questions/2776135/last-observation-carried-forward-in-a-data-frame
lvcf_mcar_data <- na.locf(mcar_data)
lvcf_mar_data <- na.locf(mar_data)
ps_match <- function(data) {
# run logistic regression of covariates on missing indicator & get predicted probs
logit <- glm(missing_ind ~ year + factor(country) + population + gdp_for_year + female + mean_age, family="binomial", data=data)
ps <- predict(logit, type="response")
data$ps <- ps
# create seperate dfs for missing and not missing data
data_missing <- data %>% filter(is.na(suicides_no))
data_not_missing <- data %>% filter(!is.na(suicides_no))
suicides_no_imp <- rep(NA, length(data_missing$ps))
for (i in 1:length(data_missing$ps)) {
ps_missing <- data_missing$ps[i]
# filter compare missing obs propensity to other propensities for observed obs within same country
missing_country <- data_missing %>%
filter(ps == ps_missing) %>%
select(country) %>% pull(.)
# take abs difference between missing obs propensity and each observed obs within country
df <- data_not_missing %>%
filter(country == missing_country) %>%
mutate(abs_diff = abs(ps_missing - ps))
# find min of abs differences
imp <- df %>%
filter(abs_diff == min(df$abs_diff)) %>%
select(suicides_no) %>%
pull(.)
suicides_no_imp[i] <- imp
}
data_missing$suicides_no_imp <- suicides_no_imp
# join imputed suicide number values to full data frame
ps_data <- data %>%
left_join(data_missing %>%
select(country_year, suicides_no_imp), by = "country_year")
# create vectors of imputed suicide values and original suicide values
ps_suicides_no_org <- ps_data %>%
filter(missing_ind == 1) %>%
select(suicides_no_org) %>% pull(.)
ps_suicides_no_imp <- ps_data %>%
filter(missing_ind == 1) %>%
select(suicides_no_imp) %>% pull(.)
mse_ps <- mean((ps_suicides_no_imp - ps_suicides_no_org)^2)
result <- list(ps_data = ps_data,
mse_ps = mse_ps)
return(result)
}
mcar_ps <- ps_match(mcar_data)
ps_mcar_data <- mcar_ps$ps_data
mar_ps <- ps_match(mar_data)
ps_mar_data <- mar_ps$ps_data
imp_mcar <- mice(mcar_data %>% select(suicides_no,mean_age,gdp_per_capita,female,year,country),group="country", method = "norm.predict", m = 1)
imp_mar <- mice(mar_data %>% select(suicides_no,mean_age,gdp_per_capita,female,year,country), group="country",method = "norm.predict", m = 1)
# Store data
data_imp_mcar <- complete(imp_mcar)
data_imp_mar <- complete(imp_mar)
impute_mcar_df <- mcar_data %>% select(suicides_no,mean_age,gdp_per_capita,female,year,country)
impute_mar_df <- mar_data %>% select(suicides_no,mean_age,gdp_per_capita,female,year,country)
#impute by country
df.clean<-lapply(split(impute_mcar_df,impute_mcar_df$country), function(x) mice::complete(mice(x[,which(names(x) != "country")],m=1,method = "norm.predict",)))
q
